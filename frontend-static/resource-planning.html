<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    </body>
  </html>

                // Find numeric IDs for the resource planning API
                // The resource-planning API expects numeric IDs, but we have UUIDs from Keka
                const selectedResource = resources.find(r => r.id === resourceId);
                const selectedProject = projects.find(p => p.id === projectId);

                // For now, we'll use a simple mapping - in production, this should be handled by the backend
                const numericResourceId = selectedResource ? resources.indexOf(selectedResource) + 1 : 1;
                const numericProjectId = selectedProject ? projects.indexOf(selectedProject) + 1 : 1;

                console.log('ID Mapping:', {
                    original: { resourceId, projectId },
                    selectedResource: selectedResource ? { id: selectedResource.id, name: selectedResource.name } : null,
                    selectedProject: selectedProject ? { id: selectedProject.id, name: selectedProject.name } : null,
                    mapped: { numericResourceId, numericProjectId }
                });

                // Create the booking object for API
                const bookingData = {
                    resourceId: numericResourceId,
                    projectId: numericProjectId,
                    startDate: startDate.toISOString().split('T')[0], // API expects YYYY-MM-DD format
                    endDate: endDate.toISOString().split('T')[0],
                    allocationMethod: currentAllocationMethod,
                    allocationValue: allocationValue,
                    type: currentBookingType
                };

                try {
                    // Save to API
                    const url = `${API_URL}/resource-planning/bookings`;
                    console.log('Creating booking with URL:', url);
                    console.log('Booking data:', bookingData);

                    const response = await makeAuthenticatedRequest(url, {
                        method: 'POST',
                        body: JSON.stringify(bookingData)
                    });

                    console.log('Response status:', response.status);
                    console.log('Response ok:', response.ok);

                    if (response.ok) {
                        const result = await response.json();
                        console.log('Booking created successfully:', result);

                        // Add to local bookings array with API response data
                        const booking = {
                            id: Date.now() + Math.random(), // Local unique ID
                            apiId: result.data.id, // API ID for updates/deletes
                            resourceId: resourceId,
                            projectId: projectId,
                            startDate: startDate,
                            endDate: endDate,
                            dailyHours: dailyHours,
                            type: currentBookingType,
                            allocationMethod: currentAllocationMethod,
                            allocationValue: allocationValue,
                            description: `${currentBookingType} booking - ${allocationValue} ${currentAllocationMethod === 'hours' ? 'hours/day' : currentAllocationMethod === 'percentage' ? '%' : 'total hours'}`
                        };

                        bookings.push(booking);
                        updateGanttChart();
                        clearForm();

                        const resourceName = resources.find(r => r.id === resourceId)?.name || 'Resource';
                        showWarning(`Booking created successfully for ${resourceName}!`, 'success');
                    } else {
                        console.error('Failed to create booking. Status:', response.status);
                        const errorText = await response.text();
                        console.error('Error response:', errorText);
                        let errorMessage = 'Unknown error';
                        try {
                            const error = JSON.parse(errorText);
                            errorMessage = error.message || error.error || 'Unknown error';
                        } catch (e) {
                            errorMessage = errorText || 'Server error';
                        }
                        showWarning(`Failed to create booking: ${errorMessage}`, 'error');
                    }
                } catch (error) {
                    console.error('Error creating booking:', error);
                    showWarning('Failed to create booking. Please try again.', 'error');
                }
            }

            // Clear form
            function clearForm() {
                document.getElementById('bookingForm').reset();

                // Reset to defaults
                currentBookingType = 'hard';
                currentAllocationMethod = 'hours';

                // Set the hard booking radio button as default
                const hardRadio = document.querySelector('input[name="bookingType"][value="hard"]');
                if (hardRadio) {
                    hardRadio.checked = true;
                }

                // Reset allocation method buttons
                document.querySelectorAll('.allocation-btn').forEach(btn => btn.classList.remove('active'));
                const firstAllocationBtn = document.querySelector('.allocation-btn');
                if (firstAllocationBtn) {
                    firstAllocationBtn.classList.add('active');
                }
            }

            // Check for overbooking
            function checkOverbooking(resourceId, startDate, endDate, dailyHours) {
                const conflictDates = [];
                const currentDate = new Date(startDate);

                while (currentDate <= endDate) {
                    if (isWorkingDay(currentDate)) {
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const existingHours = getTotalHoursForResourceOnDate(resourceId, currentDate);

                        if (existingHours + dailyHours > 8) {
                            conflictDates.push(dateStr);
                        }
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                return {
                    isOverbooked: conflictDates.length > 0,
                    conflictDates: conflictDates
                };
            }

            // Get total hours for resource on specific date
            function getTotalHoursForResourceOnDate(resourceId, date) {
                const dateStr = date.toISOString().split('T')[0];
                return bookings
                    .filter(b => b.resourceId === resourceId &&
                               new Date(b.startDate).toISOString().split('T')[0] <= dateStr &&
                               new Date(b.endDate).toISOString().split('T')[0] >= dateStr)
                    .reduce((total, b) => total + b.dailyHours, 0);
            }

            // Utility functions
            function isWorkingDay(date) {
                const day = date.getDay();
                return day !== 0 && day !== 6; // Not Sunday or Saturday
            }

            function getWorkingDaysBetween(startDate, endDate) {
                let count = 0;
                const currentDate = new Date(startDate);

                while (currentDate <= endDate) {
                    if (isWorkingDay(currentDate)) {
                        count++;
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                return count;
            }

            // Show warning messages
            function showWarning(message, type = 'warning') {
                const container = document.getElementById('warningContainer');
                const warning = document.createElement('div');
                warning.className = `warning-message ${type}`;
                warning.innerHTML = `
                    <span class="warning-icon">${type === 'error' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : 'üí°'}</span>
                    <span>${message}</span>
                `;

                container.innerHTML = '';
                container.appendChild(warning);

                // Auto-hide after 5 seconds
                setTimeout(() => {
                    warning.remove();
                }, 5000);
            }

            // Initialize Gantt chart
            function initializeGanttChart() {
                updateGanttChart();
            }

            // Update Gantt chart
            function updateGanttChart() {
                updateResourceList();
                updateTimelineHeader();
                updateResourceTimelines();
                updateCurrentPeriod();

                // Re-setup synchronized scrolling after DOM updates
                setTimeout(() => {
                    setupSynchronizedScrolling();
                }, 100);
            }

            // Update resource list (supports both project and resource views)
            function updateResourceList() {
                if (currentViewMode === 'project') {
                    updateResourceListByProject();
                } else {
                    updateResourceListByResource();
                }
            }

            // Update resource list grouped by projects
            function updateResourceListByProject() {
                const container = document.getElementById('resourceList');
                container.innerHTML = '';

                projects.forEach(project => {
                    // Get resources allocated to this project
                    const projectResources = getResourcesForProject(project.id);

                    // Skip projects with no resources
                    if (projectResources.length === 0) return;

                    // Create project group
                    const projectGroup = document.createElement('div');
                    projectGroup.className = 'project-group';

                    // Create project header
                    const projectHeader = document.createElement('div');
                    projectHeader.className = `project-header ${project.expanded ? 'expanded' : ''}`;
                    projectHeader.innerHTML = `
                        <div class="project-header-info">
                            <div class="project-expand-icon">‚ñ∂</div>
                            <div class="project-details">
                                <div class="project-name">${project.name}</div>
                                <div class="project-meta">${project.client} ‚Ä¢ <span class="project-status ${project.status.toLowerCase()}">${project.status}</span></div>
                            </div>
                        </div>
                    `;

                    // Add click handler for expand/collapse
                    projectHeader.addEventListener('click', (e) => {
                        // Defensive: prevent any accidental navigation if nested links ever appear
                        e.preventDefault();
                        e.stopPropagation();
                        const beforeUrl = window.location.href;
                        const beforeProtocol = window.location.protocol;
                        console.log('[EXPAND PROJECT CLICK]', {
                            projectId: project.id,
                            name: project.name,
                            previousExpanded: project.expanded,
                            location: beforeUrl,
                            protocol: beforeProtocol
                        });
                        project.expanded = !project.expanded;
                        projectHeader.className = `project-header ${project.expanded ? 'expanded' : ''}`;
                        const resourcesContainer = projectGroup.querySelector('.project-resources');
                        resourcesContainer.className = `project-resources ${project.expanded ? 'expanded' : ''}`;
                        updateResourceTimelines(); // Update timelines to match
                        console.log('[EXPAND PROJECT AFTER]', { projectId: project.id, expanded: project.expanded });
                    });

                    projectGroup.appendChild(projectHeader);

                    // Create resources container
                    const resourcesContainer = document.createElement('div');
                    resourcesContainer.className = `project-resources ${project.expanded ? 'expanded' : ''}`;

                    // Add resources for this project
                    projectResources.forEach(resource => {
                        const resourceElement = document.createElement('div');
                        resourceElement.className = `resource-row ${currentView === 'monthly' ? 'monthly-view' : ''}`;
                        resourceElement.innerHTML = `
                            <div class="resource-info project-resource-info">
                                <div class="resource-details">
                                    <div class="resource-name">${resource.name}</div>
                                    <div class="resource-capacity">Capacity: ${resource.capacity}h/day</div>
                                </div>
                            </div>
                        `;
                        resourcesContainer.appendChild(resourceElement);
                    });

                    projectGroup.appendChild(resourcesContainer);
                    container.appendChild(projectGroup);
                });
            }

            // Update resource list grouped by resources (original view)
            function updateResourceListByResource() {
                console.log('updateResourceListByResource called');
                const container = document.getElementById('resourceList');
                if (!container) {
                    // Build arrays for both containers, then append all at once to guarantee row count and order match
                    const resourceRows = [];
                    const timelineRows = [];
                    resources.forEach(resource => {
                        // Calculate comprehensive utilization metrics for this resource
                        const resourceBookings = bookings.filter(b => b.resourceId === resource.id);
                        if (!container || !timelineContainer) return;
                        container.innerHTML = '';
                        timelineContainer.innerHTML = '';
                        resources.forEach(resource => {
                            // Main resource row
                            const resourceElement = document.createElement('div');
                            resourceElement.className = `resource-row ${currentView === 'monthly' ? 'monthly-view' : ''}`;
                            const expandClass = resource.expanded ? 'expanded' : '';
                            resourceElement.innerHTML = `
                                <div class="resource-info">
                                    <div class="resource-expand-icon ${expandClass}" data-resource-id="${resource.id}">‚ñ∂</div>
                                    <div class="resource-details">
                                        <div class="resource-name">${resource.name}</div>
                                        <div class="resource-capacity">Capacity: ${resource.capacity}h/day</div>
                                    </div>
                                </div>
                            `;
                            container.appendChild(resourceElement);
                            // Attach expand/collapse
                            const expandEl = resourceElement.querySelector('.resource-expand-icon');
                            if (expandEl) {
                                expandEl.addEventListener('click', () => toggleResourceExpansion(resource.id));
                            }
                            // Timeline row for main resource
                            const timelineElement = document.createElement('div');
                            timelineElement.className = `resource-row ${currentView === 'monthly' ? 'monthly-view' : ''}`;
                            timelineElement.innerHTML = `<div class="resource-timeline" id="timeline-${resource.id}"></div>`;
                            timelineContainer.appendChild(timelineElement);
                            // Add sub-rows if expanded
                            if (resource.expanded && SHOW_RESOURCE_DETAIL_SUBROWS) {
                                const projectAllocations = getProjectAllocationsForResource(resource.id);
                                projectAllocations.forEach(allocation => {
                                    // Sub-row for resourceList
                                    const subRowElement = document.createElement('div');
                                    subRowElement.className = 'resource-sub-row';
                                    subRowElement.innerHTML = `
                                        <div class="resource-info" style="padding-left: 40px;">
                                            <div class="resource-details">
                                                <div class="resource-name" style="font-size: 13px; color: #6c757d;">${allocation.project.name}</div>
                                            </div>
                                        </div>
                                    `;
                                    container.appendChild(subRowElement);
                                    // Sub-row for resourceTimelines
                                    const emptyTimelineRow = document.createElement('div');
                                    emptyTimelineRow.className = 'resource-sub-row';
                                    emptyTimelineRow.innerHTML = `<div class="resource-timeline"></div>`;
                                    timelineContainer.appendChild(emptyTimelineRow);
                                });
                            }
                    const bookingEnd = new Date(booking.endDate);
                    const hours = booking.hours || booking.dailyHours || booking.allocationValue || 0;

                    // Calculate total allocation hours (sum of all booking hours)
                    const bookingDays = Math.ceil((bookingEnd - bookingStart) / (1000 * 60 * 60 * 24)) + 1;
                    totalAllocationHours += hours * bookingDays;

                    // Debug log for resource 1 (John Smith)
                    if (resourceId === 1) {
                    }

                    // Map daily concurrent allocations
                    for (let date = new Date(bookingStart); date <= bookingEnd; date.setDate(date.getDate() + 1)) {
                        const dateKey = date.toISOString().split('T')[0];
                        if (!dailyAllocations[dateKey]) {
                            dailyAllocations[dateKey] = { hours: 0, projects: [] };
                        }
                        dailyAllocations[dateKey].hours += hours;
                        dailyAllocations[dateKey].projects.push({
                            projectId: booking.projectId,
                            projectName: projects.find(p => p.id === booking.projectId)?.name || 'Unknown',
                            hours: hours
                        });
                    }
                });

                // Find maximum concurrent hours and peak dates
                const maxConcurrentHours = Math.max(...Object.values(dailyAllocations).map(d => d.hours));
                const peakDates = Object.entries(dailyAllocations)
                    .filter(([date, allocation]) => allocation.hours === maxConcurrentHours)
                    .map(([date]) => date)
                    // --- BEGIN: Moved orphaned JS from after </script> ---
                    function setBookingType(type) {
                      currentBookingType = type;
                      // Update radio button selection (the radio buttons handle their own visual state)
                      const radioButton = document.querySelector(`input[name="bookingType"][value="${type}"]`);
                      if (radioButton) {
                        radioButton.checked = true;
                      }
                      console.log('Booking type set to:', type);
                    }

                    // Allocation method selection
                    function setAllocationMethod(method) {
                      currentAllocationMethod = method;
                      document.querySelectorAll('.allocation-btn').forEach(btn => btn.classList.remove('active'));
                      event.target.classList.add('active');

                      const input = document.getElementById('allocationValue');
                      switch(method) {
                        case 'hours':
                if (typeof arguments[0] === 'object' && arguments[1] === undefined) {
                    </script>
                    return maxConcurrentHours;
                }

                return {
                    maxConcurrentHours,
                    totalPercentage: Math.min(totalPercentage, 100),
                    peakPercentage: Math.min(peakPercentage, 100),
                    peakDates,
                    dailyBreakdown,
					totalAllocationHours
				};




// ...existing code...




    if (allocation && allocation > 0) {
      const left = (index * dayWidth) + (dayWidth / 2) - 12;
      const isOverAllocated = (currentView === 'daily' && allocation > 8) ||
                  (currentView === 'weekly' && allocation > 40) ||
                  (currentView === 'monthly' && allocation > 160);
      const badgeClass = isOverAllocated ? 'over-allocated' : '';
      const suffix = currentView === 'daily' ? 'h' : currentView === 'weekly' ? 'h/w' : 'h/m';
      numbersHtml += '<div class="allocation-number ' + badgeClass + '"'
        + ' style="left: ' + left + 'px; position: absolute; top: 50%; transform: translateY(-50%); z-index: 25; pointer-events: none;"'
        + ' title="' + currentView + ' allocation: ' + allocation + ' hours' + (isOverAllocated ? ' (Over-allocated!)' : '') + '">' 
        + allocation + suffix + '</div>';
    }
  });
  return numbersHtml;
}

function calculateDailyAllocation(bookings, day) {
  let totalHours = 0;
  const dayKey = day.toDateString();
  bookings.forEach(booking => {
    const bookingStart = new Date(booking.startDate);
    const bookingEnd = new Date(booking.endDate);
    const hours = booking.hours || booking.dailyHours || booking.allocationValue || 0;
    if (day >= bookingStart && day <= bookingEnd) {
      const dayOfWeek = day.getDay();
      if (dayOfWeek >= 1 && dayOfWeek <= 5) {
        totalHours += hours;
      }
    }
  });
  return totalHours;
}

function calculateWeeklyAllocation(bookings, weekStart) {
  let totalHours = 0;
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekEnd.getDate() + 6);
  bookings.forEach(booking => {
    const bookingStart = new Date(booking.startDate);
    const bookingEnd = new Date(booking.endDate);
    const hours = booking.hours || booking.dailyHours || booking.allocationValue || 0;
    const overlapStart = new Date(Math.max(bookingStart.getTime(), weekStart.getTime()));
    const overlapEnd = new Date(Math.min(bookingEnd.getTime(), weekEnd.getTime()));
    if (overlapStart <= overlapEnd) {
      const currentDay = new Date(overlapStart);
      while (currentDay <= overlapEnd) {
        const dayOfWeek = currentDay.getDay();
        if (dayOfWeek >= 1 && dayOfWeek <= 5) {
          totalHours += hours;
        }
        currentDay.setDate(currentDay.getDate() + 1);
      }
    }
  });
  return totalHours;
}

function calculateMonthlyAllocation(bookings, monthStart) {
  let totalHours = 0;
  const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
  bookings.forEach(booking => {
    const bookingStart = new Date(booking.startDate);
    const bookingEnd = new Date(booking.endDate);
    const hours = booking.hours || booking.dailyHours || booking.allocationValue || 0;
    const overlapStart = new Date(Math.max(bookingStart.getTime(), monthStart.getTime()));
    const overlapEnd = new Date(Math.min(bookingEnd.getTime(), monthEnd.getTime()));
    if (overlapStart <= overlapEnd) {
      const currentDay = new Date(overlapStart);
      while (currentDay <= overlapEnd) {
        const dayOfWeek = currentDay.getDay();
        if (dayOfWeek >= 1 && dayOfWeek <= 5) {
          totalHours += hours;
        }
        currentDay.setDate(currentDay.getDate() + 1);
      }
    }
  });
  return totalHours;
}

function generateCapacityIndicators(resourceId, capacity, dayWidth = 60) {
  return '';
}

function getDaysInCurrentView() {
  const startDateInput = document.getElementById('calendarStartDate').value;
  const endDateInput = document.getElementById('calendarEndDate').value;
  if (!startDateInput || !endDateInput) {
    return getDefaultDaysInCurrentView();
  }
  if (!validateCalendarDateRange()) {
    return getDefaultDaysInCurrentView();
  }
  const startDate = new Date(startDateInput);
  const endDate = new Date(endDateInput);
  const days = [];
  switch(currentView) {
    case 'daily':
      const currentDate = new Date(startDate);
      const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
      if (daysDiff > 90) {
        while (currentDate <= endDate) {
          days.push(new Date(currentDate));
          currentDate.setDate(currentDate.getDate() + 1);
        }
      } else {
        while (currentDate <= endDate) {
          days.push(new Date(currentDate));
          currentDate.setDate(currentDate.getDate() + 1);
        }
      }
      break;
    case 'weekly':
      const weekStart = new Date(startDate);
      const startDayOfWeek = weekStart.getDay();
      const mondayOffset = startDayOfWeek === 0 ? -6 : 1 - startDayOfWeek;
      weekStart.setDate(weekStart.getDate() + mondayOffset);
      const currentWeek = new Date(weekStart);
      while (currentWeek <= endDate) {
        days.push(new Date(currentWeek));
        currentWeek.setDate(currentWeek.getDate() + 7);
      }
      break;
    case 'monthly':
      const monthStart = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      const currentMonth = new Date(monthStart);
      while (currentMonth <= endDate) {
        days.push(new Date(currentMonth));
        currentMonth.setMonth(currentMonth.getMonth() + 1);
      }
      break;
  }
  return days;
}

function getDefaultDaysInCurrentView() {
  const days = [];
  const startDate = getViewStartDate();
  const endDate = getViewEndDate();
  const currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay();
    if (dayOfWeek >= 1 && dayOfWeek <= 5) {
      days.push(new Date(currentDate));
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
  return days;
}

function getViewStartDate() {
  const date = new Date(currentDate);
  switch(currentView) {
    case 'daily':
      return new Date(date);
    case 'weekly':
      const dayOfWeek = date.getDay();
      const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
      date.setDate(date.getDate() + mondayOffset);
      return new Date(date);
    case 'monthly':
      date.setDate(1);
      return new Date(date);
    default:
      return new Date(date);
  }
}

function getViewEndDate() {
  const startDate = getViewStartDate();
  const endDate = new Date(startDate);
  switch(currentView) {
    case 'daily':
      endDate.setDate(endDate.getDate() + 13);
      break;
    case 'weekly':
      endDate.setDate(endDate.getDate() + 27);
      break;
    case 'monthly':
      endDate.setMonth(endDate.getMonth() + 3);
      endDate.setDate(endDate.getDate() - 1);
      break;
  }
  return endDate;
}

function generateWeekHeaders(days) {
  if (!days || days.length === 0) return '';
  let html = '';
  let currentWeek = '';
  let weekStart = 0;
  const dayWidth = 60;
  days.forEach(function(day, index) {
    var weekNumber = getISOWeekNumber(day);
    var weekLabel = 'W' + weekNumber;
    if (weekLabel !== currentWeek) {
    if (currentWeek) {
      var width = (index - weekStart) * dayWidth;
      html += '<div class="timeline-week" style="width: ' + width + 'px; min-width: ' + width + 'px; flex-shrink: 0;">' + currentWeek + '</div>';
    }
    currentWeek = weekLabel;
    weekStart = index;
    }
  });
  if (currentWeek) {
    var width = (days.length - weekStart) * dayWidth;
    html += '<div class="timeline-week" style="width: ' + width + 'px; min-width: ' + width + 'px; flex-shrink: 0;">' + currentWeek + '</div>';
  }
  return html;
}

function getISOWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
  return weekNo;
}

function generateMonthHeaders(days) {
  if (!days || days.length === 0) return '';
  let html = '';
  let currentMonth = '';
  let monthStart = 0;
  const dayWidth = calculateOptimalDayWidth(days.length);
  days.forEach(function(day, index) {
    var monthName = day.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
    if (monthName !== currentMonth) {
    if (currentMonth) {
      var width = (index - monthStart) * dayWidth;
      html += '<div class="timeline-month" style="width: ' + width + 'px; min-width: ' + width + 'px; flex-shrink: 0;">' + currentMonth + '</div>';
    }
    currentMonth = monthName;
    monthStart = index;
    }
  });
  if (currentMonth) {
    var width = (days.length - monthStart) * dayWidth;
    html += '<div class="timeline-month" style="width: ' + width + 'px; min-width: ' + width + 'px; flex-shrink: 0;">' + currentMonth + '</div>';
  }
  return html;
}

function generateDayHeaders(days) {
  if (!days || days.length === 0) return '';
  var dayWidth = calculateOptimalDayWidth(days.length);
  var html = '';
  var i;
  switch(currentView) {
    case 'daily':
    for (i = 0; i < days.length; i++) {
      var day = days[i];
      var isToday = day.toDateString() === new Date().toDateString();
      var dayNumber = day.getDate();
      var dayName = day.toLocaleDateString('en-US', { weekday: 'short' });
      html += '<div style="'
      + 'width: ' + dayWidth + 'px;'
      + 'min-width: ' + dayWidth + 'px;'
      + 'border-right: 1px solid #e9ecef;'
      + 'display: flex;'
      + 'flex-direction: column;'
      + 'align-items: center;'
      + 'justify-content: center;'
      + 'font-size: 12px;'
      + 'font-weight: 500;'
      + 'background: ' + (isToday ? '#e8f5e8' : '#fafafa') + ';'
      + 'flex-shrink: 0;'
      + 'padding: 4px 2px;'
      + '">';
      html += '<div style="font-size: 10px; line-height: 1; color: #6c757d;">' + dayName + '</div>';
      html += '<div style="font-size: 12px; font-weight: 600; color: ' + (isToday ? '#155724' : '#495057') + ';">' + dayNumber + '</div>';
      html += '</div>';
    }
    return html;
    case 'weekly':
    for (i = 0; i < days.length; i++) {
      var weekStart = days[i];
      var weekEnd = new Date(weekStart);
      weekEnd.setDate(weekEnd.getDate() + 6);
      var weekNumber = getISOWeekNumber(weekStart);
      html += '<div style="'
      + 'width: ' + dayWidth + 'px;'
      + 'min-width: ' + dayWidth + 'px;'
      + 'border-right: 1px solid #e9ecef;'
      + 'display: flex;'
      + 'flex-direction: column;'
      + 'align-items: center;'
      + 'justify-content: center;'
      + 'font-size: 12px;'
      + 'font-weight: 500;'
      + 'background: #fafafa;'
      + 'flex-shrink: 0;'
      + 'padding: 4px 2px;'
      + '">';
      html += '<div style="font-size: 10px; line-height: 1; color: #6c757d;">Week ' + weekNumber + '</div>';
      html += '<div style="font-size: 11px; font-weight: 600; color: #495057;">' + weekStart.getDate() + '-' + weekEnd.getDate() + '</div>';
      html += '</div>';
    }
    return html;
    case 'monthly':
    for (i = 0; i < days.length; i++) {
      var monthStart = days[i];
      var monthName = monthStart.toLocaleDateString('en-US', { month: 'short' });
      var year = monthStart.getFullYear();
      html += '<div style="'
      + 'width: ' + dayWidth + 'px;'
      + 'min-width: ' + dayWidth + 'px;'
      + 'border-right: 1px solid #e9ecef;'
      + 'display: flex;'
      + 'flex-direction: column;'
      + 'align-items: center;'
      + 'justify-content: center;'
      + 'font-size: 12px;'
      + 'font-weight: 500;'
      + 'background: #fafafa;'
      + 'flex-shrink: 0;'
      + 'padding: 4px 2px;'
      + '">';
      html += '<div style="font-size: 10px; line-height: 1; color: #6c757d;">' + monthName + '</div>';
      html += '<div style="font-size: 12px; font-weight: 600; color: #495057;">' + year + '</div>';
      html += '</div>';
    }
    return html;
    default:
    return '';
  }
}

function navigateTimeframe(direction) {
  switch(currentView) {
    case 'daily':
      currentDate.setDate(currentDate.getDate() + (direction * 14));
      break;
    case 'weekly':
      currentDate.setDate(currentDate.getDate() + (direction * 28));
      break;
    case 'monthly':
      currentDate.setMonth(currentDate.getMonth() + (direction * 3));
      break;
  }
  updateGanttChart();
}

function updateCurrentPeriod() {
  // Function kept for compatibility but currentPeriod element removed
  // Period information is now shown in calendarDateInfo only
}
// --- END: Consolidated Orphaned JS Functions ---



  <!-- Context Menu and Edit Modal are now rendered dynamically by JS. -->
  </body>
</html>